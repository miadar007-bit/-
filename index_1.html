<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Побег из лабиринта</title>
  <style>
    :root {
      --bg: #0f1226;
      --panel: #171a35;
      --accent: #6ee7ff;
      --good: #22c55e;
      --warn: #f59e0b;
      --danger: #ef4444;
      --text: #e6e7ef;
      --muted: #9aa0b4;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: radial-gradient(1200px 800px at 20% 0%, #13173a 0%, #0c0f22 60%, #0a0c1b 100%);
      color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      display: grid; place-items: center; padding: 16px;
    }
    .app {
      width: min(1100px, 100%);
      display: grid; gap: 12px;
    }
    .header {
      display: flex; align-items: center; justify-content: space-between; gap: 12px;
    }
    h1 {
      margin: 0; font-size: clamp(20px, 3.4vw, 34px); letter-spacing: 0.4px;
      background: linear-gradient(90deg, #c4f1ff, #7bd6ff 40%, #6ee7ff 60%, #b9f7ff);
      -webkit-background-clip: text; background-clip: text; color: transparent;
      text-shadow: 0 0 24px rgba(110,231,255,.25);
    }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    button {
      background: linear-gradient(180deg, #22284f, #161a33);
      color: var(--text); border: 1px solid #2b3163; border-radius: 14px;
      padding: 10px 14px; cursor: pointer; font-weight: 600; letter-spacing: .2px;
      box-shadow: 0 6px 20px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.06);
      transition: transform .06s ease, box-shadow .2s ease, border-color .2s ease, background .2s ease;
    }
    button:hover { transform: translateY(-1px); border-color: #3b4290; }
    button:active { transform: translateY(0); }
    .pill {
      padding: 10px 12px; border-radius: 12px; background: #121530; border: 1px solid #2a2f5d;
      display: inline-flex; align-items: center; gap: 10px; min-height: 40px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .pill b { color: #cfe7ff; }
    .grid {
      display: grid; grid-template-columns: 1fr 320px; gap: 12px;
    }
    @media (max-width: 900px) {
      .grid { grid-template-columns: 1fr; }
    }
    .panel {
      background: linear-gradient(180deg, #14183a, #10132d 60%, #0d1030);
      border: 1px solid #2b3163; border-radius: 18px; padding: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.33), inset 0 1px 0 rgba(255,255,255,.05);
    }
    .canvas-wrap { position: relative; aspect-ratio: 1 / 1; width: 100%; }
    canvas { width: 100%; height: 100%; display: block; border-radius: 14px; background: #0a0d23; }

    .stats { display: grid; gap: 8px; }
    .row { display: flex; align-items: center; justify-content: space-between; }
    .value { font-variant-numeric: tabular-nums; }
    .muted { color: var(--muted); font-size: 13px; }
    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      background: #0b0e23; padding: 2px 6px; border-radius: 6px; border: 1px solid #273070; font-size: 12px;
    }
    .hint { font-size: 14px; color: #c7d7ff; }
    .badge { font-size: 12px; padding: 2px 8px; border-radius: 999px; background: #0b1427; border: 1px solid #23325e; }
    .good { color: var(--good); }
    .warn { color: var(--warn); }
    .danger { color: var(--danger); }
    .footer { text-align: center; font-size: 12px; color: var(--muted); margin-top: 2px; }
  </style>
</head>
<body>
  <div class="app">
    <div class="header">
      <h1>Побег из лабиринта</h1>
      <div class="controls">
        <button id="btnNew">↻ Новый лабиринт</button>
        <div class="pill"><b>Сложность:</b>
          <select id="difficulty" aria-label="Сложность">
            <option value="small">Малый</option>
            <option value="medium" selected>Средний</option>
            <option value="large">Большой</option>
          </select>
        </div>
      </div>
    </div>

    <div class="grid">
      <div class="panel">
        <div class="canvas-wrap">
          <canvas id="maze"></canvas>
        </div>
      </div>

      <div class="panel stats" role="status" aria-live="polite">
        <div class="row"><div>Время</div><div class="value" id="time">00:00.0</div></div>
        <div class="row"><div>Шаги</div><div class="value" id="steps">0</div></div>
        <div class="row"><div>Кратчайший путь</div><div class="value" id="bestLen">—</div></div>
        <div class="row"><div>Эффективность</div><div class="value" id="eff">—</div></div>
        <div class="row"><div>Личный рекорд</div><div class="value" id="pb">—</div></div>
        <hr style="border: none; border-top: 1px solid #252a57; margin: 8px 0;">
        <div class="hint">
          Управление: стрелки <span class="kbd">↑</span><span class="kbd">↓</span><span class="kbd">←</span><span class="kbd">→</span> или WASD. Начало — слева сверху, финиш — справа снизу.
        </div>
        <div class="muted">Бонус за кратчайший путь: завершите лабиринт ровно за минимальное количество шагов — получите отметку «Идеальный маршрут».</div>
        <div id="message" class="badge" style="margin-top:6px; display:none"></div>
      </div>
    </div>
    <div class="footer">© Побег из лабиринта. Один HTML‑файл, без библиотек.</div>
  </div>

<script>
(() => {
  // ---------- Конфигурация ----------
  const canvas = document.getElementById('maze');
  const ctx = canvas.getContext('2d');
  const elTime = document.getElementById('time');
  const elSteps = document.getElementById('steps');
  const elBestLen = document.getElementById('bestLen');
  const elEff = document.getElementById('eff');
  const elMsg = document.getElementById('message');
  const elPB = document.getElementById('pb');
  const btnNew = document.getElementById('btnNew');
  const ddDiff = document.getElementById('difficulty');

  let cols = 21, rows = 21; // значения по умолчанию (средний)
  const wallColor = '#1b2256';
  const pathColor = '#0b0f2a';
  const gridColor = '#11153a';
  const startColor = '#3b82f6';
  const goalColor = '#22c55e';
  const avatarColor = '#f97316';

  function setDifficulty(val){
    switch(val){
      case 'small': cols = 15; rows = 15; break;
      case 'large': cols = 31; rows = 31; break;
      default: cols = 21; rows = 21; break;
    }
  }

  // ---------- Генерация лабиринта (DFS backtracker) ----------
  function makeGrid(c, r){
    const grid = new Array(r);
    for(let y=0; y<r; y++){
      grid[y] = new Array(c);
      for(let x=0; x<c; x++){
        grid[y][x] = { x, y, visited:false, walls:[true,true,true,true] }; // top,right,bottom,left
      }
    }
    return grid;
  }

  function neighbors(grid, cell){
    const res = [];
    const {x,y} = cell;
    if(y>0) res.push(grid[y-1][x]);
    if(x<cols-1) res.push(grid[y][x+1]);
    if(y<rows-1) res.push(grid[y+1][x]);
    if(x>0) res.push(grid[y][x-1]);
    return res;
  }

  function carve(a,b){
    const dx = b.x - a.x; const dy = b.y - a.y;
    if(dx === 1){ a.walls[1]=false; b.walls[3]=false; }
    else if(dx === -1){ a.walls[3]=false; b.walls[1]=false; }
    else if(dy === 1){ a.walls[2]=false; b.walls[0]=false; }
    else if(dy === -1){ a.walls[0]=false; b.walls[2]=false; }
  }

  function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }

  function generateMaze(){
    const grid = makeGrid(cols, rows);
    const stack = [];
    const start = grid[0][0];
    start.visited = true;
    stack.push(start);

    while(stack.length){
      const current = stack[stack.length-1];
      const unvisited = neighbors(grid, current).filter(n => !n.visited);
      if(unvisited.length){
        const nxt = shuffle(unvisited)[0];
        carve(current, nxt);
        nxt.visited = true;
        stack.push(nxt);
      } else {
        stack.pop();
      }
    }
    return grid;
  }

  // ---------- BFS для кратчайшего пути ----------
  function shortestPathLen(grid){
    const q = [];
    const dist = Array.from({length: rows}, () => Array(cols).fill(Infinity));
    dist[0][0] = 0; q.push([0,0]);
    while(q.length){
      const [y,x] = q.shift();
      const d = dist[y][x];
      const cell = grid[y][x];
      // top
      if(!cell.walls[0] && dist[y-1][x] > d+1){ dist[y-1][x] = d+1; q.push([y-1,x]); }
      // right
      if(!cell.walls[1] && dist[y][x+1] > d+1){ dist[y][x+1] = d+1; q.push([y,x+1]); }
      // bottom
      if(!cell.walls[2] && dist[y+1][x] > d+1){ dist[y+1][x] = d+1; q.push([y+1,x]); }
      // left
      if(!cell.walls[3] && dist[y][x-1] > d+1){ dist[y][x-1] = d+1; q.push([y,x-1]); }
    }
    return dist[rows-1][cols-1];
  }

  // ---------- Рендер ----------
  let grid, cellSize, margin, avatar = {x:0,y:0}, steps=0, started=false, startTs=0, timerId=null, bestLen=0, finished=false;

  function layout(){
    // квадратный канвас по контейнеру
    const rect = canvas.parentElement.getBoundingClientRect();
    const size = Math.floor(Math.min(rect.width, rect.height));
    canvas.width = size * devicePixelRatio;
    canvas.height = size * devicePixelRatio;
    canvas.style.width = size + 'px';
    canvas.style.height = size + 'px';
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);

    // выравнивание сетки с полями
    const pad = 12; // внутренний отступ
    const w = size - pad*2;
    cellSize = Math.floor(w / cols);
    margin = Math.floor((size - cellSize*cols) / 2);
    drawAll();
  }

  function drawAll(){
    // фон
    ctx.fillStyle = pathColor;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // клетки
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const c = grid[y][x];
        const px = margin + x*cellSize;
        const py = margin + y*cellSize;
        // сетка слегкa
        ctx.fillStyle = pathColor;
        ctx.fillRect(px,py,cellSize,cellSize);

        // стены
        ctx.strokeStyle = wallColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        if(c.walls[0]){ ctx.moveTo(px,py); ctx.lineTo(px+cellSize,py); }
        if(c.walls[1]){ ctx.moveTo(px+cellSize,py); ctx.lineTo(px+cellSize,py+cellSize); }
        if(c.walls[2]){ ctx.moveTo(px,py+cellSize); ctx.lineTo(px+cellSize,py+cellSize); }
        if(c.walls[3]){ ctx.moveTo(px,py); ctx.lineTo(px,py+cellSize); }
        ctx.stroke();
      }
    }

    // старт и финиш
    drawCellBg(0,0,startColor,0.15);
    drawCellInset(0,0,startColor);
    drawCellBg(rows-1,cols-1,goalColor,0.15);
    drawCellInset(rows-1,cols-1,goalColor);

    // аватар
    drawAvatar();
  }

  function drawCellBg(y,x,color,alpha=0.2){
    const px = margin + x*cellSize;
    const py = margin + y*cellSize;
    ctx.fillStyle = hexA(color, alpha);
    ctx.fillRect(px,py,cellSize,cellSize);
  }
  function drawCellInset(y,x,color){
    const px = margin + x*cellSize + 4;
    const py = margin + y*cellSize + 4;
    const s = cellSize - 8;
    ctx.fillStyle = hexA(color, .25);
    ctx.fillRect(px,py,s,s);
  }

  function drawAvatar(){
    const px = margin + avatar.x*cellSize + cellSize/2;
    const py = margin + avatar.y*cellSize + cellSize/2;
    const r = Math.max(6, Math.floor(cellSize*0.28));
    // тень
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,0,0,.35)';
    ctx.ellipse(px, py + r*0.35, r*0.9, r*0.5, 0, 0, Math.PI*2);
    ctx.fill();
    // сам аватар
    ctx.beginPath();
    ctx.fillStyle = avatarColor;
    ctx.arc(px,py,r,0,Math.PI*2);
    ctx.fill();
    // блик
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,.45)';
    ctx.arc(px - r*0.4, py - r*0.4, r*0.35, 0, Math.PI*2);
    ctx.fill();
  }

  function hexA(hex, a){
    // принимает #rrggbb
    const r = parseInt(hex.slice(1,3),16);
    const g = parseInt(hex.slice(3,5),16);
    const b = parseInt(hex.slice(5,7),16);
    return `rgba(${r},${g},${b},${a})`;
  }

  // ---------- Игровая логика ----------
  function resetGame(){
    grid = generateMaze();
    bestLen = shortestPathLen(grid);
    avatar = {x:0, y:0};
    steps = 0; started = false; finished = false;
    stopTimer();
    updateUI();
    layout();
    announce('Новый лабиринт готов. Удачи!');
  }

  function canMove(dx,dy){
    if(finished) return false;
    const {x,y} = avatar;
    const cell = grid[y][x];
    if(dx===0 && dy===-1 && !cell.walls[0]) return true; // up
    if(dx===1 && dy===0 && !cell.walls[1]) return true; // right
    if(dx===0 && dy===1 && !cell.walls[2]) return true; // down
    if(dx===-1 && dy===0 && !cell.walls[3]) return true; // left
    return false;
  }

  function move(dx,dy){
    if(!started){ started = true; startTimer(); }
    if(canMove(dx,dy)){
      avatar.x += dx; avatar.y += dy; steps++;
      drawAll();
      updateUI();
      if(avatar.x === cols-1 && avatar.y === rows-1){ onFinish(); }
    } else {
      // лёгкий импульс стены
      pulseCell(avatar.y, avatar.x, '#ef444433');
    }
  }

  function pulseCell(y,x,fill){
    const px = margin + x*cellSize;
    const py = margin + y*cellSize;
    ctx.save();
    ctx.fillStyle = fill;
    ctx.fillRect(px,py,cellSize,cellSize);
    setTimeout(()=>{ drawAll(); }, 60);
    ctx.restore();
  }

  function onFinish(){
    finished = true; stopTimer();
    const msg = steps === bestLen ? 'Идеальный маршрут! +Бонус' : (steps < bestLen*1.2 ? 'Отличный результат!' : 'Финиш! Попробуйте лучше.');
    showMessage(msg, steps===bestLen? 'good' : (steps < bestLen*1.2 ? 'warn' : 'danger'));

    // сохранить личный рекорд (по времени) в localStorage для текущей сложности и размеров
    const key = pbKey();
    const timeMs = performance.now() - startTs;
    const prev = JSON.parse(localStorage.getItem(key) || 'null');
    if(!prev || timeMs < prev.timeMs || (timeMs === prev.timeMs && steps < prev.steps)){
      localStorage.setItem(key, JSON.stringify({ timeMs, steps, cols, rows }));
      announce('Новый личный рекорд!');
    }
    updateUI();
  }

  function pbKey(){ return `maze_pb_${cols}x${rows}`; }

  function getPB(){
    const rec = JSON.parse(localStorage.getItem(pbKey()) || 'null');
    return rec;
  }

  // ---------- Таймер ----------
  function startTimer(){
    startTs = performance.now();
    timerId = setInterval(()=>{ updateTime(); }, 100);
  }
  function stopTimer(){ if(timerId){ clearInterval(timerId); timerId=null; } updateTime(); }
  function msToString(ms){
    const t = Math.floor(ms);
    const m = Math.floor(t/60000); const s = Math.floor((t%60000)/1000); const d = Math.floor((t%1000)/100);
    return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${d}`;
  }
  function updateTime(){
    const ms = started ? (finished ? (startTs? (finishTs - startTs):0) : (performance.now()-startTs)) : 0;
    elTime.textContent = msToString(ms);
  }

  // хранить момент финиша
  let finishTs = 0;
  function markFinishTs(){ finishTs = performance.now(); }

  // ---------- UI helpers ----------
  function updateUI(){
    elSteps.textContent = steps;
    elBestLen.textContent = isFinite(bestLen) ? bestLen : '—';
    const eff = bestLen ? Math.max(0, Math.round(100 * bestLen / Math.max(steps||1, bestLen))) : 0;
    elEff.textContent = steps? `${eff}%` : '—';

    const rec = getPB();
    if(rec){ elPB.textContent = `${msToString(rec.timeMs)} · ${rec.steps} шагов (${rec.cols}×${rec.rows})`; }
    else { elPB.textContent = '—'; }
  }
  function showMessage(text, tone='warn'){
    elMsg.textContent = text; elMsg.className = `badge ${tone}`; elMsg.style.display = 'inline-block';
    setTimeout(()=>{ elMsg.style.display = 'none'; }, 4000);
  }
  function announce(text){
    // базовый aria-live уже есть; можно коротко вспыхнуть бейдж
    showMessage(text, 'warn');
  }

  // ---------- События ----------
  window.addEventListener('resize', layout);

  window.addEventListener('keydown', (e) => {
    const key = e.key.toLowerCase();
    if(['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d'].includes(key)){
      e.preventDefault();
      const m = { 'arrowup':[0,-1], 'w':[0,-1], 'arrowright':[1,0], 'd':[1,0], 'arrowdown':[0,1], 's':[0,1], 'arrowleft':[-1,0], 'a':[-1,0] };
      const [dx,dy] = m[key];
      const before = steps;
      move(dx,dy);
      if(finished && steps>before) { markFinishTs(); updateTime(); }
    }
  });

  btnNew.addEventListener('click', () => { resetGame(); });
  ddDiff.addEventListener('change', (e)=>{ setDifficulty(e.target.value); resetGame(); });

  // ---------- Старт ----------
  setDifficulty(ddDiff.value);
  resetGame();
})();
</script>
</body>
</html>
